# 비교 연산자
<br/>

**`비교 연산자`** 는 **동등(==, !=) 또는 크기(<, <=, >, >=)를 평가**해서 `boolean 타입`인 true/false를 산출한다. 비교 연산자는 흐름 제어문인 조건문(if), 반복문(for, while)에서
**실행 흐름을 제어할 때 주로 사용**된다.

|구분|연산식|설명|
|:---|:---|:---|
|동등<br/>비교|피연산자1 **==** 피연산자2<br/>피연산자1 **!=** &nbsp;피연산자2|두 피연산자의 값이 **같은지**를 검사<br/>두 피연산자의 값이 **다른지**를 검사|
|크기<br/>비교|피연산자1 **>** &nbsp;&nbsp;피연산자2<br/>피연산자1 **>=** 피연산자2<br/>피연산자1 **<** &nbsp;&nbsp;피연산자2<br/>피연산자1 **<=** 피연산자2|피연산자1이 **큰지**를 검사<br/>피연산자1이 **크거나 같은지**를 검사<br/>피연산자1이 **작은지**를 검사<br/>피연산자1이 **작거나 같은지**를 검사|

피연산자의 타입이 다를 경우에는 비교 연산을 수행하기 전에 타입을 일치시킨다. 예를 들어 'A' == 65는 'A'가 int 타입으로 변환되어 65가 된 다음 65 == 65로 비교한다.
마찬가지로 3 == 3.0은 3을 double 타입인 3.0으로 변환한 다음 3.0 == 3.0으로 비교한다.
```java
'A' == 65  → true
3 == 3.0   → true
```
한 가지 **예외**가 있다. `0.1f == 0.1`에서 0.1f가 double 타입으로 변환되면 0.1 == 0.1이 되어 true가 산출되어야 하지만, 이 결괏값은 `false`가 산출된다.
```java
0.1f == 0.1  → false
```
그 이유는 **부동 소수점 방식**을 사용하는 실수 타입은 0.1을 정확히 표현할 수 없을 뿐만 아니라 float 타입과 double 타입의 **정밀도 차이** 때문이다.
해결책은 다음과 같이 피연산자를 **`float` 타입으로 강제 타입 변환** 후에 비교 연산을 하면 된다.
```java
0.1f == (float) 0.1  → true
```
**문자열을 비교**할 때에는 동등(==, !=) 연산자 대신 `equals()`와 `!equals()`를 사용한다.
```java
boolean result = str1.equals(str2);    // 문자열이 같은지 검사(대소문자 구분)
boolean result = !str1.equals(str2);   // 문자열이 다른지 검사
```
- [CompareOperatorExample.java](https://github.com/silxbro/java/blob/main/src/thisisjava/ch03/sec06/CompareOperatorExample.java)
